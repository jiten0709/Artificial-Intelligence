import os
import time
import asyncio
import logging
from typing import List, Dict, Optional
from concurrent.futures import ThreadPoolExecutor

import openai
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()

# Set up logging configuration
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

# Constants
client = openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
model = "gpt-4o"
MAX_RETRIES = 3
RETRY_DELAY = 2  # seconds

# --------------------------------------------------------------
# Step 1: Define the data models
# --------------------------------------------------------------

class SubTask(BaseModel):
    """Blog section task defined by the orchestrator."""
    section_type: str = Field(description="type of blog section to write")
    description: str = Field(description="what this section should cover")
    style_guide: str = Field(description="writing style for this section")
    target_length: int = Field(description="target length in words for this section")


class OrchestratorPlan(BaseModel):
    """Orchestrator's blog structure and tasks"""
    topic_analysis: str = Field(description="analysis of the blog topic")
    target_audience: str = Field(description="intended audience for the blog")
    sections: List[SubTask] = Field(description="list of sections to be written")


class SectionContent(BaseModel):
    """Content generated by a worker for a specific section."""
    content: str = Field(description="written content for the section")
    key_points: List[str] = Field(description="key points covered in the section")


class SuggestedEdits(BaseModel):
    """Suggested edits for a section"""
    section_name: str = Field(description="name of the section to edit")
    suggested_edit: str = Field(description="suggested edits for the section content")


class ReviewFeedback(BaseModel):
    """Final review and suggestions for the blog"""
    cohesion_score: float = Field(description="how well the sections fit together (0-1)")
    suggested_edits: List[SuggestedEdits] = Field(description="list of suggested edits by section")
    final_version: str = Field(description="complete, polished blog post")


# --------------------------------------------------------------
# Step 2: Define the prompts
# --------------------------------------------------------------

ORCHESTRATOR_PROMPT = """
Analyze this blog topic and break it down into logical sections.

Topic: {topic}
Target Length: {target_length} words
Style: {style}

Return your response in this format:

# Analysis
Analyze the topic and explain how it should be structured.
Consider the narrative flow and how sections will work together.

# Target Audience
Define the target audience and their interests/needs.

# Sections
## Section 1
- Type: section_type
- Description: what this section should cover
- Style: writing style guidelines

[Additional sections as needed...]
"""

WORKER_PROMPT = """
Write a blog section based on:
Topic: {topic}
Section Type: {section_type}
Section Goal: {description}
Style Guide: {style_guide}
Target Length: {target_length} words

Previous Sections:
{previous_sections}

Return your response in this format:

# Content
[Your section content here, following the style guide]

# Key Points
- Main point 1
- Main point 2
[Additional points as needed...]
"""

REVIEWER_PROMPT = """
Review this blog post for cohesion and flow:

Topic: {topic}
Target Audience: {audience}

Sections:
{sections}

Provide a cohesion score between 0.0 and 1.0, suggested edits for each section if needed, and a final polished version of the complete post.

The cohesion score should reflect how well the sections flow together, with 1.0 being perfect cohesion.
For suggested edits, focus on improving transitions and maintaining consistent tone across sections.
The final version should incorporate your suggested improvements into a polished, cohesive blog post.
"""


# --------------------------------------------------------------
# Step 3: Helper functions with error handling
# --------------------------------------------------------------

def make_api_call_with_retries(func, *args, **kwargs):
    """Make API call with retries for handling rate limits and network errors."""
    for attempt in range(MAX_RETRIES):
        try:
            return func(*args, **kwargs)
        except openai.RateLimitError:
            wait_time = (2 ** attempt) * RETRY_DELAY
            logger.warning(f"Rate limit hit. Retrying in {wait_time} seconds...")
            time.sleep(wait_time)
        except openai.APIError as e:
            logger.error(f"API error: {str(e)}")
            if attempt < MAX_RETRIES - 1:
                wait_time = (2 ** attempt) * RETRY_DELAY
                logger.info(f"Retrying in {wait_time} seconds...")
                time.sleep(wait_time)
            else:
                raise
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}")
            raise
    
    raise Exception(f"Failed after {MAX_RETRIES} retries")


async def write_section_async(orchestrator, topic: str, section: SubTask, previous_sections: str) -> SectionContent:
    """Asynchronous wrapper for section writing to allow parallel processing."""
    def _write_section():
        try:
            completion = client.chat.completions.create(
                model=model,
                messages=[
                    {
                        "role": "system",
                        "content": WORKER_PROMPT.format(
                            topic=topic,
                            section_type=section.section_type,
                            description=section.description,
                            style_guide=section.style_guide,
                            target_length=section.target_length,
                            previous_sections=previous_sections
                        )
                    }
                ],
                response_format={"type": "json_object"},
                tools=[
                    {
                        "type": "function",
                        "function": {
                            "name": "write_blog_section",
                            "description": "Write a blog section based on the provided details",
                            "parameters": SectionContent.model_json_schema()
                        }
                    }
                ],
                tool_choice={"type": "function", "function": {"name": "write_blog_section"}},
            )
            
            tool_call = completion.choices[0].message.tool_calls[0]
            return SectionContent.model_validate_json(tool_call.function.arguments)
        except Exception as e:
            logger.error(f"Error writing section {section.section_type}: {str(e)}")
            raise
    
    # Run in a thread pool to avoid blocking the event loop
    loop = asyncio.get_event_loop()
    with ThreadPoolExecutor() as executor:
        return await loop.run_in_executor(executor, _write_section)


# --------------------------------------------------------------
# Step 4: Implement orchestrator
# --------------------------------------------------------------

class BlogOrchestrator:
    def __init__(self):
        self.sections_content = {}

    def get_plan(self, topic: str, target_length: int, style: str) -> OrchestratorPlan:
        """Get orchestrator's structure plan for the blog with error handling."""
        try:
            return make_api_call_with_retries(
                lambda: client.chat.completions.create(
                    model=model,
                    messages=[
                        {
                            "role": "system",
                            "content": ORCHESTRATOR_PROMPT.format(
                                topic=topic, target_length=target_length, style=style
                            )
                        }
                    ],
                    response_format={"type": "json_object"},
                    tools=[
                        {
                            "type": "function",
                            "function": {
                                "name": "create_blog_plan",
                                "description": "Create a structured plan for the blog",
                                "parameters": OrchestratorPlan.model_json_schema()
                            }
                        }
                    ],
                    tool_choice={"type": "function", "function": {"name": "create_blog_plan"}},
                )
            )
        except Exception as e:
            logger.error(f"Error creating blog plan: {str(e)}")
            raise

    def write_section(self, topic: str, section: SubTask) -> SectionContent:
        """Write a specific blog section (synchronous version)."""
        # Create context from previously written sections
        previous_sections = ""
        if self.sections_content:
            previous_sections = "\n\n".join(
                [
                    f"=== {section_type} ===\n{content.content}"
                    for section_type, content in self.sections_content.items()
                ]
            )
        else:
            previous_sections = "This is the first section."

        try:
            return make_api_call_with_retries(
                lambda: client.chat.completions.create(
                    model=model,
                    messages=[
                        {
                            "role": "system",
                            "content": WORKER_PROMPT.format(
                                topic=topic,
                                section_type=section.section_type,
                                description=section.description,
                                style_guide=section.style_guide,
                                target_length=section.target_length,
                                previous_sections=previous_sections
                            )
                        }
                    ],
                    response_format={"type": "json_object"},
                    tools=[
                        {
                            "type": "function",
                            "function": {
                                "name": "write_blog_section",
                                "description": "Write a blog section based on the provided details",
                                "parameters": SectionContent.model_json_schema()
                            }
                        }
                    ],
                    tool_choice={"type": "function", "function": {"name": "write_blog_section"}},
                )
            ).choices[0].message.tool_calls[0].function.arguments
        except Exception as e:
            logger.error(f"Error writing section {section.section_type}: {str(e)}")
            raise

    def review_blog(self, topic: str, plan: OrchestratorPlan) -> ReviewFeedback:
        """Review the entire blog for cohesion and flow."""
        sections_text = "\n\n".join(
            [
                f"=== {section_type} ===\n{content.content}"
                for section_type, content in self.sections_content.items()
            ]
        )

        try:
            completion = make_api_call_with_retries(
                lambda: client.chat.completions.create(
                    model=model,
                    messages=[
                        {
                            "role": "system",
                            "content": REVIEWER_PROMPT.format(
                                topic=topic,
                                audience=plan.target_audience,
                                sections=sections_text,
                            )
                        }
                    ],
                    response_format={"type": "json_object"},
                    tools=[
                        {
                            "type": "function",
                            "function": {
                                "name": "provide_review_feedback",
                                "description": "provide feedback and review for the blog post",
                                "parameters": ReviewFeedback.model_json_schema()
                            }
                        }
                    ],
                    tool_choice={"type": "function", "function": {"name": "provide_review_feedback"}},
                )
            )
            
            tool_call = completion.choices[0].message.tool_calls[0]
            return ReviewFeedback.model_validate_json(tool_call.function.arguments)
        except Exception as e:
            logger.error(f"Error reviewing blog: {str(e)}")
            raise

    async def write_sections_in_parallel(self, topic: str, plan: OrchestratorPlan) -> Dict[str, SectionContent]:
        """Write all sections in parallel using async."""
        # First collect the context for all sections
        previous_sections = "This is the first section."
        
        # Create tasks for each section
        tasks = []
        for section in plan.sections:
            tasks.append(write_section_async(self, topic, section, previous_sections))
        
        # Execute all section writing tasks in parallel
        section_contents = await asyncio.gather(*tasks)
        
        # Store the results
        sections_dict = {}
        for i, section in enumerate(plan.sections):
            sections_dict[section.section_type] = section_contents[i]
        
        return sections_dict

    def write_blog(self, topic: str, target_length: int = 1000, style: str = "informative") -> Dict:
        """Main method to orchestrate the blog writing process."""
        start_time = time.time()
        logger.info(f"Starting blog writing process for topic: {topic}")
        
        try:
            # Step 1: Get the orchestrator's plan (synchronous)
            logger.info("Creating blog structure plan...")
            plan = self.get_plan(topic, target_length, style)
            logger.info(f"Blog structure planned: {len(plan.sections)} sections")
            
            # Step 2: Write all sections in parallel (async)
            logger.info("Writing sections in parallel...")
            self.sections_content = asyncio.run(self.write_sections_in_parallel(topic, plan))
            logger.info(f"All {len(self.sections_content)} sections written successfully")
            
            # Step 3: Review the blog (synchronous)
            logger.info("Reviewing and polishing the blog...")
            review = self.review_blog(topic, plan)
            
            end_time = time.time()
            logger.info(f"Blog writing completed in {end_time - start_time:.2f} seconds")
            
            return {
                "structure": plan,
                "sections": self.sections_content,
                "review": review
            }
        except Exception as e:
            logger.error(f"Error in blog writing process: {str(e)}")
            raise
    

# --------------------------------------------------------------
# Step 5: Example usage
# --------------------------------------------------------------

if __name__ == "__main__":
    try:
        orchestrator = BlogOrchestrator()

        topic = "The Future of AI in Healthcare"
        target_length = 1500
        style = "informative"

        blog_result = orchestrator.write_blog(topic, target_length, style)

        print("\n\n=== FINAL BLOG POST ===\n")
        print(blog_result['review'].final_version)

        print(f"\nCOHESION SCORE: {blog_result['review'].cohesion_score}")
        if blog_result['review'].suggested_edits:
            print("\n=== SUGGESTED EDITS ===")
            for edit in blog_result['review'].suggested_edits:
                print(f"Section: {edit.section_name}")
                print(f"Suggested Edit: {edit.suggested_edit}")
                print()

        # Save the final blog post to a file
        with open("final_blog_post.txt", "w") as f:
            f.write(blog_result['review'].final_version)

        logger.info("Final blog post saved to 'final_blog_post.txt'")
    
    except Exception as e:
        logger.error(f"Error in blog generation process: {str(e)}")
        print(f"An error occurred: {str(e)}")

# ----------------------------------------------------
# old code for reference
# ----------------------------------------------------

# import os
# from dotenv import load_dotenv
# load_dotenv()

# import openai
# from pydantic import BaseModel, Field
# import logging
# from typing import List, Dict

# logging.basicConfig(
#     level=logging.INFO,
#     format="%(asctime)s - %(levelname)s - %(message)s",
#     datefmt="%Y-%m-%d %H:%M:%S",
# )
# logger = logging.getLogger(__name__)

# client = openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
# model = "gpt-4o"

# # --------------------------------------------------------------
# # Step 1: Define the data models
# # --------------------------------------------------------------

# class SubTask(BaseModel):
#     """blog section task defined by the orchestrator."""

#     section_type: str = Field(description="type of blog section to write ")
#     description: str = Field(description="what this section should cover")
#     style_guide: str = Field(description="writing style for this section")
#     target_length: int = Field(description="target length in words for this section")

# class OrchestratorPlan(BaseModel):
#     """Orchestrator's blog structure and tasks"""

#     topic_analysis: str = Field(description="analysis of the blog topic")
#     target_audience: str = Field(description="intended audience for the blog")
#     sections: List[SubTask] = Field(description="list of sections to be written")

# class SectionContent(BaseModel):
#     """Content generated by a worker for a specific section."""

#     content: str = Field(description="written content for the section")
#     key_points: List[str] = Field(description="key points covered in the section")

# class SuggestedEdits(BaseModel):
#     """Suggested edits for a section"""

#     section_name: str = Field(description="name of the section to edit")
#     suggested_edit: str = Field(description="suggested edits for the section content")

# class ReviewFeedback(BaseModel):
#     """final review and suggestions for the blog"""

#     cohesion_score: float = Field(description="how well the sections fit together (0-1)")
#     suggested_edits: List[SuggestedEdits] = Field(description="list of suggested edits by section")
#     final_version: str = Field(description="complete, polished blog post")

# # --------------------------------------------------------------
# # Step 2: Define the prompts
# # --------------------------------------------------------------

# ORCHESTRATOR_PROMPT = """
# Analyze this blog topic and break it down into logical sections.

# Topic: {topic}
# Target Length: {target_length} words
# Style: {style}

# Return your response in this format:

# # Analysis
# Analyze the topic and explain how it should be structured.
# Consider the narrative flow and how sections will work together.

# # Target Audience
# Define the target audience and their interests/needs.

# # Sections
# ## Section 1
# - Type: section_type
# - Description: what this section should cover
# - Style: writing style guidelines

# [Additional sections as needed...]
# """

# WORKER_PROMPT = """
# Write a blog section based on:
# Topic: {topic}
# Section Type: {section_type}
# Section Goal: {description}
# Style Guide: {style_guide}

# Return your response in this format:

# # Content
# [Your section content here, following the style guide]

# # Key Points
# - Main point 1
# - Main point 2
# [Additional points as needed...]
# """

# REVIEWER_PROMPT = """
# Review this blog post for cohesion and flow:

# Topic: {topic}
# Target Audience: {audience}

# Sections:
# {sections}

# Provide a cohesion score between 0.0 and 1.0, suggested edits for each section if needed, and a final polished version of the complete post.

# The cohesion score should reflect how well the sections flow together, with 1.0 being perfect cohesion.
# For suggested edits, focus on improving transitions and maintaining consistent tone across sections.
# The final version should incorporate your suggested improvements into a polished, cohesive blog post.
# """

# # --------------------------------------------------------------
# # Step 3: Implement orchestrator
# # --------------------------------------------------------------

# class BlogOrchestrator:
#     def __init__(self):
#         self.sections_content = {}

#     def get_plan(self, topic: str, target_lenght: int, style: str) -> OrchestratorPlan:
#         """get orchestrator's structure plan for the blog"""

#         completion = client.chat.completions.create(
#             model=model,
#             messages=[
#                 {
#                     "role": "system",
#                     "content": ORCHESTRATOR_PROMPT.format(
#                         topic=topic, target_lenght=target_lenght, style=style
#                     )
#                 }
#             ],
#             response_format={"type": "json_object"},
#             tools=[
#                 {
#                     "type": "function",
#                     "function": {
#                         "name": "create_blog_plan",
#                         "description": "Create a structured plan for the blog",
#                         "parameters": OrchestratorPlan.model_json_schema()
#                     }
#                 }
#             ],
#             tool_choice={"type": "function", "function": {"name": "create_blog_plan"}},
#         )

#         tool_call = completion.choices[0].message.tool_calls[0]

#         return OrchestratorPlan.model_validate_json(tool_call.function.arguments)

#     def write_section(self, topic: str, section: SubTask):
#         """Worker: Write a specific blog section with context from previous sections.

#         Args:
#             topic: The main blog topic
#             section: SubTask containing section details

#         Returns:
#             SectionContent: The written content and key points
#         """

#         # create context from previously written sections
#         previous_sections = "\n\n".join(
#             [
#                 f"\n\n=== {section_type} ===\n{content.content}"
#                 for section_type, content in self.sections_content.items()
#             ]
#         )

#         completion = client.chat.completions.create(
#             model=model,
#             messages=[
#                 {
#                     "role": "system",
#                     "content": WORKER_PROMPT.format(
#                         topic=topic,
#                         section_type=section.section_type,
#                         description=section.description,
#                         style_guide=section.style_guide,
#                         target_length=section.target_length,
#                         previous_sections=previous_sections if previous_sections else "this is the first section"
#                     ),
#                 }
#             ],
#             response_format={"type": "json_object"},
#             tools=[
#                 {
#                     "type": "function",
#                     "function": {
#                         "name": "write_blog_section",
#                         "description": "Write a blog section based on the provided details",
#                         "parameters": SectionContent.model_json_schema()
#                     }
#                 }
#             ],
#             tool_choice={"type": "function", "function": {"name": "write_blog_section"}},
#         )

#         tool_call = completion.choices[0].message.tool_calls[0]

#         return SectionContent.model_validate_json(tool_call.function.arguments)

#     def review_blog(self, topic: str, plan: OrchestratorPlan) -> ReviewFeedback:
#         """Worker: Review the entire blog for cohesion and flow.

#         Returns:
#             ReviewFeedback: The review feedback including cohesion score, suggested edits, and final version
#         """

#         sections_text = "\n\n".join(
#             [
#                 f"\n\n=== {section_type} ===\n{content.content}"
#                 for section_type, content in self.sections_content.items()
#             ]
#         )

#         completion = client.chat.completions.create(
#             model=model,
#             messages=[
#                 {
#                     "role": "system",
#                     "content": REVIEWER_PROMPT.format(
#                         topic=topic,
#                         audience=plan.target_audience,
#                         sections=sections_text,
#                     )
#                 }
#             ],
#             response_format={"type": "json_object"},
#             tools=[
#                 {
#                     "type": "function",
#                     "function": {
#                         "name": "provide_review_feedback",
#                         "description": "provide feedback and review for the blog post",
#                         "parameters": ReviewFeedback.model_json_schema()
#                     }
#                 }
#             ],
#             tool_choice={"type": "function", "function": {"name": "provide_review_feedback"}},
#        )
        
#         tool_call = completion.choices[0].message.tool_calls[0]

#         return ReviewFeedback.model_validate_json(tool_call.function.arguments)

#     def write_blog(self, topic: str, target_length: int = 1000, style: str = "informative") -> Dict:
#         """Main method to orchestrate the blog writing process.

#         Args:
#             topic: The main topic of the blog
#             target_length: Target length of the blog in words
#             style: Writing style for the blog


#         Returns:
#             Dict: Final blog post and review feedback
#         """

#         logger.info("Starting blog writing process for topic: %s", topic)

#         # Step 1: Get the orchestrator's plan

#         plan = self.get_plan(topic, target_length, style)
#         logger.info(f"Orchestrator plan created: {len(plan.sections)} sections")
#         logger.info(f"blog structure plan: {plan.model_dump_json(indent=2)}")

#         # Step 2: Write each section using workers

#         for section in plan.sections:
#             logger.info(f"Writing section: {section.section_type}")
#             content = self.write_section(topic, section)
#             self.sections_content[section.section_type] = content

#         # Step 3: Review the entire blog and polish it

#         logger.info("Reviewing the entire blog for cohesion and flow")
#         review_feedback = self.review_blog(topic, plan)

#         return {
#             "structure": plan,
#             "sections": self.sections_content,
#             "review": review_feedback
#         }
    
# # --------------------------------------------------------------
# # Step 4: Example usage
# # --------------------------------------------------------------

# if __name__ == "__main__":
#     orchestrator = BlogOrchestrator()

#     topic = "The Future of AI in Healthcare"
#     target_length = 1500
#     style = "informative"

#     blog_result = orchestrator.write_blog(topic, target_length, style)

#     logger.info("Blog writing process completed successfully!")
#     logger.info(f"Final blog structure: {blog_result['structure'].model_dump_json(indent=2)}")
#     logger.info(f"Sections content: {blog_result['sections']}")
#     logger.info(f"Review feedback: {blog_result['review'].model_dump_json(indent=2)}")

#     print("\n\n=== FINAL BLOG POST ===\n")
#     print(blog_result['review'].final_version)

#     print("\nCOHESION SCORE:", blog_result['review'].cohesion_score)    
#     if blog_result['review'].suggested_edits:
#         print("\nSUGGESTED EDITS:")
#         for edit in blog_result['review'].suggested_edits:
#             print(f"- {edit.section_name}: {edit.suggested_edit}")

#     # Save the final blog post to a file
#     with open("final_blog_post.txt", "w") as f:
#         f.write(blog_result['review'].final_version)

#     logger.info("Final blog post saved to 'final_blog_post.txt'")
